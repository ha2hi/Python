### 프로듀서
Kafka의 메시지를 전송하는 애플리케이션이다.  
- 순서 보장
  - 프로듀서는 메시지 키를 통해 동일한 파티션에 데이터 전송 가능
  - 키가 null인 경우 RR방식으로 데이터 전송
  - 키가 null이 아닌 경우(문자, 숫자) 해싱을 통해 데이터 전송
  - 해싱은 partition = hash(key) % numPartitions, hash(key)는 murmur2 해시 함수의 결과
- 직렬화(Serialization)
  - 네트워크를 통해 데이터를 전송하고 디스크에 데이터를 저장하기 위해서는 직렬화를 통해 바이너리 파일로 변환해야됨.
  - Key와 Value를 프로듀서를 통해 직렬화한 후 kafka에 전송

### 컨슈머
컨슈머는 Kafka의 메시지를 읽는 애플리케이션이다.
- 컨슈머는 Pull 방식을 통해 데이터를 읽음
- 파티션에서 데이터를 읽을 때 낮은 오프셋에서 높은 오프셋으로 순차적으로 데이터를 읽는다.
- 여러 파티션에서 데이터를 읽는 경우 어떤 파티션을 먼저 읽을지 모른다.
- 역직렬화(de-Serialization)
  - 컨슈머에서 역직렬화하기 위해 미리 데이터 타입을 알아야한다.
  - 프로듀서에서 갑작스럽게 데이터 타입을 변경하는 경우 에러가 발생
  - 타입 변경이 있는 경우 새 토픽을 만들거나 avro 타입을 사용

### 컨슈머 그룹
컨슈머들은 하나의 컨슈머 그룹으로 관리하여 데이터를 읽는다.  
- 컨슈머 그룹에 있는 컨슈머는 각각 다른 파티션을 읽는다.
- `컨슈머 수` > `파티션 수` 경우 데이터를 읽지 않는 컨슈머가 존재하게 됨.  
  
1. At-most-once(최대 1번 전달)
- 메시지가 한 번만 전송되거나 전혀 전달되지 않을 수 있는 방식
- 빠르지만 데이터 유실 가능성 존재  
2. At-least-once(최소 1번 전달)
- 메시지를 반드시 전달하지만, 중복될 수 있는 방식
- 일반적으로 Kafka의 기본 동작이며, 중복 제거 로직이 필요한 시스템에 적합  
3. Exactly-once(정확히 1번)
- 메시지를 단 한 번만 처리하는 것을 보장하는 방식
- Kafka는 Kafka Stream 혹은 Flink 등을 통해 구현이 필요

### 브로커
- 브로커는 카프카의 서버
- 브로커는 정수의 ID로 식별
- 브로커를 브트스트랩 서버라고도 함.
- Kafka Client는 1개의 브로커와 연결하면 모든 클러스터의 브로커와 연결됨.
  - 브로커 1개가 모든 브로커의 정보를 제공하기 때문
  
### Replication factor
- 브로커가 장애가 발생하는 경우를 위해 데이터 사본을 저장하기 위한 것을 말함.
- 브로커 1개가 파티션의 리더가 됨.
- ISR이란 리더 파티션과 팔로워 파티션의 집합을 의미
- 프로듀서는 파티션의 리더에게 데이터를 전송
- 컨슈머는 파티션의 리더 브로커에서 데이터를 읽음
- Kafka 2.4버전 이후 Replica Fetching 기능이 추가
  - 컨슈머는 가장 가까운 레플리카에서 데이터를 읽는 기술
  
### Producer Acknowledgement(acks)
- 프로듀서는 acks를 통해 Kafka에 데이터가 정상적으로 저장됐는지 확인
-  acks=0 : 브로커의 응답을 기다리지 않음(데이터 유실 가능)
-  acks=1 : 리더 브로커의 응답을 기다림
-  acks=all : ISR의 모든 응답을 기다림
  
### 주키퍼
- 주키퍼는 브로커를 관리하는 역할
- 브로커가 다운될 때 새로운 리더를 선정
- 토픽 생성, 변경, 브로커 상태와 같은 메타데이터를 관리
- 주키퍼는 홀수 개수로 생성됨.(1,3,5,7)
  - 최대 7개까지 사용 가능
  
### KRaft Mode
- Kafka 3.x 버전 이후 주키퍼 사용하지 않고 카프카를 사용할 수 있는 기능