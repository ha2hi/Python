### Producer(프로듀서)
- producer는 key_serializer와 value_serializer을 통해 직렬화함.
- Producer 객체를 close하기 전 flush하는 이유
  - 프로듀서는 브로커에 메시지를 전달 하기 전 버퍼에 저장 후 배치로 전송
  - 이 때 flush를 하지 않고 close를 하면 버퍼에 저장된 데이터가 전송이 되지 않기 때문에 유실 가능성이 있다.
  - 버퍼에 저장하는 시간은 batch_size, 크기는 linger_ms를 통해 설정
- 파티션 전략
  - 키기반 파티셔닝
    - 동일한 키는 동일한 파티션으로 이동(순서 보장 가능)
    - murmur2 해시 전략
    - 특정 파티션에 데이터가 몰릴 수 있음
  - 라운드로빈 파티션
    - 레코드를 전송할 때 마다 다른 파티션에 보내기 때문에 균등 분배
    - 스티키파티션에 비해 비효율적
  - 스티키파티션(default)
    - 레코드를 배치 단위로 한 번에 파티션에 보내기 때문에 효율적
  - kakfa-python 라이브러리에서 `partitioner` 옵션으로 지정 가능

### Consumer(컨슈머)
- Consumer는 key_deserializr와 value_desrializer를 통해 역직렬화 함.
- auto.offset.reset을 통해 메시지를 어디서 부터 읽을지 설정 가능
  - none : 커밋된 offset 정보가 없을 때 예외를 발생
  - earliest : 가장 처음(offset 0)부터 읽음
  - latest : 이후 생성되는 메시지부터 읽음, 이전 메시지 읽지 않음
- Consumer는 Poll을 통해 레코드를 가져오고, 레코드 처리가 완료되면 commit함.  
- Shutdown Hook을 통해 애플리케이션 종료 시 graceful하게 종료되도록 설정하는 것이 좋음
  - 안정성, 신뢰성, 무결성을 보장하기 위해 구현 필요
- 파티션 리밸런싱
  - 컨슈머 그룹 내의 컨슈머 추가 및 삭제 시 혹은 파티션 추가 및 삭제가 되는 경우 파티션 리밸런싱 과정이 이뤄짐
  - Eager Rebalance : 모든 읽기 작업이 중단되고, 리밸런싱 이후 읽기 작업이 재개
    - RangeAssignor :연속적인 범위로 파티션을 할당
    - RoundRobinAssignor : 라운드로빈(균등하게)방식으로 파티션을 할당
    - StickyAssignor : 기존 컨슈머가 담당하는 파티션은 최대한 유지한채로 균등하게 파티션 할당
  - Cooperative Rebalance : 읽기 과정을 유지한채로 리밸런싱이 이뤄짐
    - Cooperative StickyAssignor : 파티션 이동을 최소화하며, 컨슈머가 리밸런싱 중에도 읽기 가능
- 브로커가 session.timeout.ms 시간 동안 하트비트를 전달 받지 못한 경우 리밸런싱 발생
- auto.coomit.interval.ms은 offset commit 발생 주기